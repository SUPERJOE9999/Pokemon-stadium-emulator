<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Pok√©mon Stadium - Online</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Mona+Sans:wght@400;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html { height: 100%; }
        
        :root {
            --fg-default: #e6edf3;
            --fg-muted: #8b949e;
            --fg-subtle: #6e7681;
            --success-fg: #50c878;
            --success-emphasis: #3da35d;
            --attention-fg: #d29922;
            --canvas-default: #1a1a25;
            --canvas-subtle: #252535;
            --canvas-inset: #0a0a15;
            --border-default: #404060;
            --border-muted: #303050;
            --accent-fg: #40c040;
            --accent-emphasis: #30a030;
            --btn-gradient: linear-gradient(145deg, #30a030, #208020);
            --btn-shadow: #104010;
            --glow-color: rgba(64, 192, 64, 0.15);
        }
        
        body.theme-pokemon { --canvas-default: #1a1708; --canvas-subtle: #2d2810; --canvas-inset: #0d0c04; --border-default: #a08020; --border-muted: #605010; --accent-fg: #ffd93d; --accent-emphasis: #f0c000; --btn-gradient: linear-gradient(145deg, #f0c000, #d4a800); --btn-shadow: #8a7000; --glow-color: rgba(240, 192, 0, 0.15); }
        
        body {
            background: var(--canvas-default);
            background-image: radial-gradient(ellipse at top, var(--glow-color) 0%, transparent 50%);
            min-height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Mona Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            padding: 10px;
            padding-top: max(10px, env(safe-area-inset-top));
            padding-bottom: max(10px, env(safe-area-inset-bottom));
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            overflow-x: hidden;
        }
        
        .container { display: flex; flex-direction: column; align-items: center; gap: 12px; width: 100%; max-width: 500px; }
        .header { display: flex; align-items: center; gap: 10px; padding: 8px 16px; background: var(--canvas-subtle); border: 1px solid var(--border-default); border-radius: 6px; width: 100%; max-width: 380px; }
        .header-icon { width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-size: 24px; }
        .header-title { display: flex; flex-direction: column; }
        .header-main { color: var(--fg-default); font-size: 16px; font-weight: 700; }
        .header-sub { color: var(--fg-muted); font-size: 11px; font-family: 'JetBrains Mono', monospace; }
        .header-badge { margin-left: auto; font-size: 10px; font-weight: 600; padding: 2px 8px; border-radius: 12px; }
        .header-badge.p1 { background: #f0c000; color: #000; }
        .header-badge.p2 { background: #6040c0; color: #fff; }
        
        .peer-status { display: flex; align-items: center; gap: 8px; padding: 6px 12px; background: var(--canvas-subtle); border: 1px solid var(--border-default); border-radius: 6px; max-width: 380px; width: 100%; font-size: 11px; font-family: 'JetBrains Mono', monospace; color: var(--fg-muted); }
        .peer-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--fg-subtle); flex-shrink: 0; }
        .peer-dot.connected { background: var(--success-fg); animation: pulse 2s ease-in-out infinite; }
        .peer-dot.connecting { background: var(--attention-fg); animation: pulse 1s ease-in-out infinite; }
        @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }
        
        .now-playing { display: none; align-items: center; gap: 8px; padding: 6px 12px; background: var(--canvas-subtle); border: 1px solid var(--border-default); border-radius: 6px; max-width: 380px; width: 100%; }
        .now-playing.show { display: flex; }
        .now-playing-icon { width: 24px; height: 24px; background: var(--success-emphasis); border-radius: 4px; display: flex; align-items: center; justify-content: center; }
        .now-playing-icon svg { width: 12px; height: 12px; fill: var(--fg-default); }
        .now-playing-text { flex: 1; min-width: 0; }
        .now-playing-label { color: var(--fg-muted); font-size: 9px; font-family: 'JetBrains Mono', monospace; }
        .now-playing-name { color: var(--fg-default); font-size: 12px; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        
        .console-body { width: min(380px, 95vw); background: var(--canvas-subtle); border-radius: 8px; padding: 12px; box-shadow: 0 8px 30px rgba(0,0,0,0.4); border: 2px solid var(--border-default); }
        .console-label { color: var(--fg-muted); font-size: 10px; font-family: 'JetBrains Mono', monospace; font-weight: bold; letter-spacing: 2px; text-align: center; margin-bottom: 8px; }
        .screen-area { width: 100%; background: var(--canvas-inset); border-radius: 6px; padding: 10px; box-shadow: inset 0 4px 15px rgba(0,0,0,0.8); }
        .options-row { display: flex; justify-content: space-between; width: 100%; padding: 0 5px; margin-bottom: 5px; }
        .options-btn { background: var(--canvas-subtle); border: 1px solid var(--border-muted); border-radius: 4px; color: var(--fg-muted); font-size: 9px; font-family: 'JetBrains Mono', monospace; padding: 3px 10px; cursor: pointer; }
        #game { width: 100%; aspect-ratio: 4/3; background: #000; border-radius: 4px; overflow: hidden; display: flex; align-items: center; justify-content: center; position: relative; }
        #game * { touch-action: none; }
        .game-placeholder { text-align: center; color: var(--fg-subtle); padding: 20px; }
        .game-placeholder svg { width: 48px; height: 48px; fill: var(--fg-subtle); margin-bottom: 10px; opacity: 0.5; }
        .game-placeholder p { font-size: 11px; font-family: 'JetBrains Mono', monospace; }
        
        .controller { width: min(380px, 95vw); background: var(--canvas-subtle); border-radius: 12px; padding: 15px; box-shadow: 0 8px 20px rgba(0,0,0,0.3); border: 2px solid var(--border-default); display: flex; flex-direction: column; gap: 12px; }
        .controls-row { display: flex; justify-content: space-between; align-items: center; padding: 0 10px; }
        .shoulder-btns { display: flex; justify-content: space-between; padding: 0 10px; gap: 8px; }
        .shoulder-btn { flex: 1; height: 28px; background: var(--btn-gradient); border: 2px solid var(--btn-shadow); border-radius: 6px; color: var(--fg-default); font-size: 11px; font-weight: bold; font-family: 'JetBrains Mono', monospace; }
        .shoulder-btn:active, .shoulder-btn.pressed { transform: translateY(2px); opacity: 0.8; }
        
        .dpad { width: 100px; height: 100px; position: relative; }
        .dpad-btn { position: absolute; background: linear-gradient(145deg, var(--canvas-subtle), var(--canvas-inset)); border: 2px solid var(--border-muted); display: flex; align-items: center; justify-content: center; color: var(--fg-muted); font-size: 16px; }
        .dpad-btn:active, .dpad-btn.pressed { background: var(--btn-gradient); color: var(--fg-default); }
        .dpad-up, .dpad-down { width: 34px; height: 36px; left: 33px; }
        .dpad-up { top: 0; border-radius: 6px 6px 0 0; }
        .dpad-down { bottom: 0; border-radius: 0 0 6px 6px; }
        .dpad-left, .dpad-right { width: 36px; height: 34px; top: 33px; }
        .dpad-left { left: 0; border-radius: 6px 0 0 6px; }
        .dpad-right { right: 0; border-radius: 0 6px 6px 0; }
        .dpad-center { position: absolute; width: 34px; height: 34px; top: 33px; left: 33px; background: var(--canvas-inset); border: 2px solid var(--border-muted); }
        
        .c-buttons { display: flex; flex-direction: column; align-items: center; gap: 2px; }
        .c-row { display: flex; gap: 20px; }
        .action-btns-n64 { display: flex; gap: 10px; }
        
        .action-btn { width: 42px; height: 42px; border-radius: 50%; background: var(--btn-gradient); border: 2px solid var(--btn-shadow); font-weight: bold; font-size: 12px; font-family: 'JetBrains Mono', monospace; color: var(--fg-default); box-shadow: 0 3px 0 var(--btn-shadow); }
        .action-btn:active, .action-btn.pressed { transform: translateY(2px); box-shadow: 0 1px 0 var(--btn-shadow); }
        .c-btn { width: 32px; height: 32px; border-radius: 50%; background: #f0c000; border: 2px solid #a08000; font-size: 9px; font-weight: bold; color: #000; }
        .c-btn:active, .c-btn.pressed { transform: translateY(2px); }
        
        .menu-btns { display: flex; justify-content: center; gap: 15px; }
        .menu-btn { width: 60px; height: 18px; background: var(--canvas-inset); border: 1px solid var(--border-muted); border-radius: 10px; color: var(--fg-muted); font-size: 8px; font-family: 'JetBrains Mono', monospace; }
        .menu-btn:active, .menu-btn.pressed { background: var(--btn-gradient); color: var(--fg-default); }
        
        .analog-zone { display: flex; justify-content: center; align-items: center; flex-direction: column; gap: 2px; }
        .analog-container { width: 110px; height: 110px; position: relative; flex-shrink: 0; }
        .analog-base { width: 110px; height: 110px; border-radius: 50%; background: radial-gradient(circle at 40% 35%, var(--canvas-subtle), var(--canvas-inset)); border: 2px solid var(--border-muted); position: relative; box-shadow: inset 0 2px 8px rgba(0,0,0,0.5); }
        .analog-stick { width: 50px; height: 50px; border-radius: 50%; background: radial-gradient(circle at 40% 35%, #555, #333); border: 2px solid #666; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 2px 6px rgba(0,0,0,0.5), inset 0 1px 2px rgba(255,255,255,0.1); transition: box-shadow 0.1s; touch-action: none; }
        .analog-stick.active { box-shadow: 0 1px 3px rgba(0,0,0,0.5); border-color: var(--accent-fg); }
        .analog-label { text-align: center; color: var(--fg-subtle); font-size: 8px; font-family: 'JetBrains Mono', monospace; letter-spacing: 1px; margin-top: 2px; }
        .btn-a-n64 { background: linear-gradient(145deg, #2070d0, #1858a8) !important; border-color: #103870 !important; box-shadow: 0 3px 0 #103870 !important; }
        .btn-a-n64:active, .btn-a-n64.pressed { box-shadow: 0 1px 0 #103870 !important; }
        
        .player-tab { display: flex; align-items: center; justify-content: center; gap: 6px; padding: 4px 14px; border-radius: 20px; font-size: 10px; font-weight: 700; font-family: 'JetBrains Mono', monospace; letter-spacing: 2px; margin: 0 auto 4px; }
        .player-tab.p1 { background: #f0c000; color: #000; }
        .player-tab.p2 { background: #6040c0; color: #fff; }
        .player-tab .dot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; animation: pulse 2s ease-in-out infinite; }
        
        .controller-p2 .shoulder-btn { background: linear-gradient(145deg, #6040c0, #4830a0); border-color: #302060; }
        .controller-p2 .dpad-btn:active, .controller-p2 .dpad-btn.pressed { background: linear-gradient(145deg, #6040c0, #4830a0); }
        .controller-p2 .action-btn { background: linear-gradient(145deg, #6040c0, #4830a0); border-color: #302060; box-shadow: 0 3px 0 #302060; }
        .controller-p2 .action-btn:active, .controller-p2 .action-btn.pressed { box-shadow: 0 1px 0 #302060; }
        .controller-p2 .btn-a-n64 { background: linear-gradient(145deg, #d04040, #b03030) !important; border-color: #702020 !important; box-shadow: 0 3px 0 #702020 !important; }
        .controller-p2 .btn-a-n64:active, .controller-p2 .btn-a-n64.pressed { box-shadow: 0 1px 0 #702020 !important; }
        .controller-p2 .c-btn { background: #e060e0; border-color: #a040a0; color: #000; }
        .controller-p2 .menu-btn:active, .controller-p2 .menu-btn.pressed { background: linear-gradient(145deg, #6040c0, #4830a0); }
        .controller-p2 .analog-stick.active { border-color: #8060e0; }
        
        .touch-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 50; cursor: pointer; border-radius: 4px; animation: overlayPulse 3s ease-in-out infinite; }
        .touch-overlay.hidden { display: none; }
        @keyframes overlayPulse { 0%,100% { background: rgba(0,0,0,0.85); } 50% { background: rgba(0,0,0,0.7); } }
        .touch-overlay svg { width: 48px; height: 48px; fill: var(--accent-fg); margin-bottom: 12px; animation: touchBounce 2s ease-in-out infinite; }
        @keyframes touchBounce { 0%,100% { transform: scale(1); } 50% { transform: scale(1.15); } }
        .touch-text { color: var(--accent-fg); font-size: 18px; font-weight: 800; font-family: 'Mona Sans', sans-serif; letter-spacing: 3px; text-transform: uppercase; text-shadow: 0 0 20px var(--glow-color); }
        .touch-sub { color: var(--fg-muted); font-size: 10px; font-family: 'JetBrains Mono', monospace; margin-top: 6px; letter-spacing: 1px; }
        
        .status { color: var(--fg-muted); font-size: 11px; text-align: center; font-family: 'JetBrains Mono', monospace; display: flex; align-items: center; justify-content: center; gap: 6px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--fg-subtle); }
        .status-dot.success { background: var(--success-fg); animation: pulse 2s ease-in-out infinite; }
        .status-dot.warning { background: var(--attention-fg); animation: pulse 1s ease-in-out infinite; }
        
        .hidden { display: none; }
        
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); backdrop-filter: blur(4px); z-index: 1000; justify-content: center; align-items: center; padding: 10px; }
        .modal.show { display: flex; }
        .modal-content { background: var(--canvas-subtle); border: 1px solid var(--border-default); border-radius: 12px; padding: 16px; width: min(360px, 95vw); max-height: 85vh; overflow-y: auto; }
        .modal-header { display: flex; align-items: center; gap: 10px; margin-bottom: 12px; padding-bottom: 10px; border-bottom: 1px solid var(--border-default); }
        .modal-header svg { width: 24px; height: 24px; fill: var(--fg-default); }
        .modal-title { color: var(--fg-default); font-size: 16px; font-weight: 700; }
        .modal-section { color: var(--fg-muted); font-size: 11px; font-family: 'JetBrains Mono', monospace; text-transform: uppercase; letter-spacing: 1px; margin: 14px 0 8px; display: flex; align-items: center; gap: 8px; }
        .modal-section::after { content: ''; flex: 1; height: 1px; background: var(--border-muted); }
        .modal-option { display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; background: var(--canvas-default); border: 1px solid var(--border-muted); border-radius: 6px; margin-bottom: 8px; }
        .modal-option label { color: var(--fg-default); font-size: 13px; font-weight: 500; }
        .modal-option button, .modal-option select { background: var(--accent-emphasis); border: none; border-radius: 6px; padding: 6px 12px; font-size: 12px; font-weight: 600; color: var(--fg-default); cursor: pointer; }
        .modal-option select { background: var(--canvas-subtle); border: 1px solid var(--border-default); max-width: 140px; }
        .modal-close { display: block; width: 100%; margin-top: 12px; padding: 10px; background: var(--canvas-default); border: 1px solid var(--border-default); border-radius: 6px; color: var(--fg-default); font-size: 14px; font-weight: 600; cursor: pointer; }
        
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body class="theme-pokemon">
    <div class="container">
        <div class="header">
            <div class="header-icon">‚ö°</div>
            <div class="header-title">
                <span class="header-main">Pok√©mon Stadium</span>
                <span class="header-sub" id="room-info">Online Battle</span>
            </div>
            <span class="header-badge" id="player-badge">P?</span>
        </div>
        
        <div class="peer-status" id="peer-status">
            <div class="peer-dot connecting" id="peer-dot"></div>
            <span id="peer-text">Connecting to opponent...</span>
        </div>
        
        <div class="now-playing" id="now-playing">
            <div class="now-playing-icon"><svg viewBox="0 0 16 16"><path d="M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0ZM1.5 8a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0Zm4.879-2.773 4.264 2.559a.25.25 0 0 1 0 .428l-4.264 2.559A.25.25 0 0 1 6 10.559V5.442a.25.25 0 0 1 .379-.215Z"/></svg></div>
            <div class="now-playing-text">
                <div class="now-playing-label">NOW PLAYING</div>
                <div class="now-playing-name" id="now-playing-name">Pok√©mon Stadium</div>
            </div>
        </div>
        
        <div class="console-body">
            <div class="console-label">POK√âMON STADIUM</div>
            <div class="screen-area">
                <div class="options-row">
                    <button class="options-btn" id="options-btn">‚öô Settings</button>
                </div>
                <div id="game">
                    <div class="game-placeholder">
                        <svg viewBox="0 0 16 16"><path d="M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0ZM1.5 8a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0Zm4.879-2.773 4.264 2.559a.25.25 0 0 1 0 .428l-4.264 2.559A.25.25 0 0 1 6 10.559V5.442a.25.25 0 0 1 .379-.215Z"/></svg>
                        <p>Loading Pok√©mon Stadium...</p>
                    </div>
                    <div class="touch-overlay" id="touch-overlay">
                        <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 14.5v-9l6 4.5-6 4.5z"/></svg>
                        <div class="touch-text">Touch to Start</div>
                        <div class="touch-sub">Pok√©mon Stadium</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- YOUR controller only (the other player's is hidden) -->
        <div id="my-controller-zone"></div>
        
        <div class="status" id="status">
            <span class="status-dot" id="status-dot"></span>
            <span id="status-text">Loading Pok√©mon Stadium...</span>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div class="modal" id="settings-modal">
        <div class="modal-content">
            <div class="modal-header">
                <svg viewBox="0 0 16 16"><path d="M8 0a8.2 8.2 0 0 1 .701.031C6.444.095 5.393.895 4.939 2H2.375A2.375 2.375 0 0 0 0 4.375v2.25A2.375 2.375 0 0 0 2.375 9h.666c.09.342.22.668.386.974L1.22 12.18a1.5 1.5 0 0 0 0 2.121l.5.5a1.5 1.5 0 0 0 2.121 0l2.206-2.207c.166-.306.296-.632.386-.974h.666A2.375 2.375 0 0 0 16 6.625v-2.25A2.375 2.375 0 0 0 13.625 2h-2.564c-.454-1.105-1.505-1.905-2.76-1.969A8.2 8.2 0 0 1 8 0Z"/></svg>
                <span class="modal-title">Settings</span>
            </div>
            <div class="modal-section">Game</div>
            <div class="modal-option"><label>Sound</label><button id="mute-btn">üîä ON</button></div>
            <div class="modal-option"><label>Screenshot</label><button id="screenshot-btn">üì∑ SNAP</button></div>
            <div class="modal-section">Save Data</div>
            <div class="modal-option"><label>Save State</label><button id="save-btn">üíæ SAVE</button></div>
            <div class="modal-option"><label>Restart</label><button id="restart-btn">üîÑ RESTART</button></div>
            <div class="modal-option"><label>Back to Lobby</label><button id="lobby-btn" onclick="window.location.href='lobby.html'">üè† LOBBY</button></div>
            <button class="modal-close" id="settings-close">Close</button>
        </div>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <script>
        // ============ CONFIG ============
        const FOLDER_ID = '1zkrluWLRYxbvZBwhrtyXRrl-R0nTPkiK';
        const API_KEY = 'AIzaSyAL1l3O7Jr8M635xZsxT3jI9yE-yp13KTc';
        const CORS_PROXIES = ['https://api.allorigins.win/raw?url=', 'https://corsproxy.io/?'];
        // Save state URL - UPDATE THIS to your GitHub Pages URL
        const SAVE_STATE_URL = 'pokemon_stadium.state';
        // ================================
        
        // Parse URL params
        const params = new URLSearchParams(window.location.search);
        const myPlayer = parseInt(params.get('player')) || 1; // 1 or 2
        const roomCode = params.get('room') || '';
        const myIndex = myPlayer - 1; // 0 for P1, 1 for P2
        
        let emu = null;
        let isMuted = false;
        let currentRomName = 'Pok√©mon Stadium';
        let currentRomBlob = null;
        let peer = null;
        let conn = null;
        let peerConnected = false;
        
        // ============ UI SETUP BASED ON PLAYER ============
        const badge = document.getElementById('player-badge');
        badge.textContent = 'P' + myPlayer;
        badge.className = 'header-badge ' + (myPlayer === 1 ? 'p1' : 'p2');
        document.getElementById('room-info').textContent = roomCode ? 'Room: ' + roomCode : 'Local Play';
        
        // Build controller HTML for this player only
        const ctrlZone = document.getElementById('my-controller-zone');
        const isP2 = myPlayer === 2;
        const prefix = isP2 ? 'p2-' : '';
        const ctrlClass = isP2 ? 'controller controller-p2' : 'controller';
        const tabClass = isP2 ? 'player-tab p2' : 'player-tab p1';
        const tabLabel = isP2 ? 'üéÆ PLAYER 2' : '‚ö° PLAYER 1';

        ctrlZone.innerHTML = `
        <div class="${tabClass}"><span class="dot"></span> ${tabLabel}</div>
        <div class="${ctrlClass}">
            <div class="shoulder-btns">
                <button class="shoulder-btn" id="${prefix}btn-l">L</button>
                <button class="shoulder-btn" id="${prefix}btn-z">Z</button>
                <button class="shoulder-btn" id="${prefix}btn-r">R</button>
            </div>
            <div class="controls-row">
                <div class="dpad">
                    <button class="dpad-btn dpad-up" id="${prefix}btn-up">‚ñ≤</button>
                    <button class="dpad-btn dpad-down" id="${prefix}btn-down">‚ñº</button>
                    <button class="dpad-btn dpad-left" id="${prefix}btn-left">‚óÄ</button>
                    <button class="dpad-btn dpad-right" id="${prefix}btn-right">‚ñ∂</button>
                    <div class="dpad-center"></div>
                </div>
                <div class="c-buttons">
                    <button class="c-btn c-up" id="${prefix}btn-cup">C‚ñ≤</button>
                    <div class="c-row">
                        <button class="c-btn c-left" id="${prefix}btn-cleft">C‚óÄ</button>
                        <button class="c-btn c-right" id="${prefix}btn-cright">C‚ñ∂</button>
                    </div>
                    <button class="c-btn c-down" id="${prefix}btn-cdown">C‚ñº</button>
                </div>
                <div class="action-btns-n64">
                    <button class="action-btn btn-a-n64" id="${prefix}btn-a">A</button>
                    <button class="action-btn btn-b" id="${prefix}btn-b">B</button>
                </div>
            </div>
            <div class="menu-btns">
                <button class="menu-btn" id="${prefix}btn-start">START</button>
            </div>
            <div class="analog-zone">
                <div class="analog-container">
                    <div class="analog-base" id="${prefix}analog-base">
                        <div class="analog-stick" id="${prefix}analog-stick"></div>
                    </div>
                </div>
                <div class="analog-label">ANALOG STICK</div>
            </div>
        </div>`;
        
        // ============ PEER CONNECTION ============
        function setupPeer() {
            if (!roomCode) {
                document.getElementById('peer-text').textContent = 'Local mode (no room code)';
                document.getElementById('peer-dot').className = 'peer-dot';
                return;
            }
            
            const myPeerId = myPlayer === 1 
                ? 'pkstadium-emu-' + roomCode 
                : 'pkstadium-emu-p2-' + roomCode;
            const remotePeerId = myPlayer === 1 
                ? 'pkstadium-emu-p2-' + roomCode 
                : 'pkstadium-emu-' + roomCode;
            
            document.getElementById('peer-text').textContent = 'Connecting...';
            document.getElementById('peer-dot').className = 'peer-dot connecting';
            
            peer = new Peer(myPeerId, {
                debug: 1,
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                }
            });
            
            peer.on('open', () => {
                // P1 waits for connection, P2 initiates
                if (myPlayer === 2) {
                    // Try connecting to P1 with retries
                    attemptConnect(remotePeerId, 0);
                } else {
                    document.getElementById('peer-text').textContent = 'Waiting for Player 2...';
                }
            });
            
            peer.on('connection', (connection) => {
                conn = connection;
                setupConnection();
            });
            
            peer.on('error', (err) => {
                console.error('Peer error:', err);
                if (err.type === 'peer-unavailable') {
                    // Retry after delay
                    setTimeout(() => attemptConnect(remotePeerId, 0), 2000);
                }
            });
        }
        
        function attemptConnect(remotePeerId, attempt) {
            if (peerConnected || attempt > 15) return;
            document.getElementById('peer-text').textContent = 'Connecting to opponent... (' + (attempt+1) + ')';
            conn = peer.connect(remotePeerId, { reliable: true });
            conn.on('open', () => setupConnection());
            conn.on('error', () => {
                setTimeout(() => attemptConnect(remotePeerId, attempt + 1), 2000);
            });
        }
        
        function setupConnection() {
            peerConnected = true;
            document.getElementById('peer-dot').className = 'peer-dot connected';
            document.getElementById('peer-text').textContent = 'Player ' + (myPlayer === 1 ? '2' : '1') + ' connected!';
            
            conn.on('data', (data) => {
                // Receive remote player's input and apply it
                if (data.type === 'input' && emu?.gameManager) {
                    emu.gameManager.simulateInput(data.player, data.code, data.value);
                }
            });
            
            conn.on('close', () => {
                peerConnected = false;
                document.getElementById('peer-dot').className = 'peer-dot';
                document.getElementById('peer-text').textContent = 'Opponent disconnected';
            });
        }
        
        function sendInput(code, value) {
            if (conn && peerConnected) {
                try {
                    conn.send({ type: 'input', player: myIndex, code: code, value: value });
                } catch(e) {}
            }
        }
        
        // ============ GOOGLE DRIVE ============
        function formatSize(bytes) {
            if (!bytes) return 'N64';
            return (bytes / 1048576).toFixed(1) + ' MB';
        }
        
        async function fetchDriveFolder() {
            const files = [];
            let pageToken = '';
            do {
                let url = `https://www.googleapis.com/drive/v3/files?q='${FOLDER_ID}'+in+parents&key=${API_KEY}&pageSize=1000&fields=nextPageToken,files(id,name,size)`;
                if (pageToken) url += `&pageToken=${pageToken}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error((await response.json()).error?.message || 'API failed');
                const data = await response.json();
                const valid = (data.files || []).filter(f => /\.(n64|z64|v64)$/i.test(f.name));
                files.push(...valid.map(f => ({ id: f.id, name: f.name.replace(/\.(n64|z64|v64)$/i, ''), size: formatSize(parseInt(f.size) || 0) })));
                pageToken = data.nextPageToken;
            } while (pageToken);
            return files;
        }
        
        async function loadRom(fileId, name) {
            const statusText = document.getElementById('status-text');
            const statusDot = document.getElementById('status-dot');
            statusDot.className = 'status-dot warning';
            statusText.textContent = `Loading ${name}...`;
            try {
                let blob = null;
                try {
                    const r = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media&key=${API_KEY}`);
                    if (r.ok) blob = await r.blob();
                } catch(e) {}
                if (!blob || blob.size < 1000) {
                    const proxyUrl = `https://drive.google.com/uc?export=download&id=${fileId}`;
                    for (const proxy of CORS_PROXIES) {
                        try {
                            const r = await fetch(proxy + encodeURIComponent(proxyUrl));
                            if (r.ok) {
                                const data = await r.blob();
                                if (data.size > 1000 && !data.type.includes('text/html')) { blob = data; break; }
                                const text = await data.text();
                                if (text.includes('confirm=')) {
                                    const match = text.match(/confirm=([^&"']+)/);
                                    if (match) {
                                        const cr = await fetch(proxy + encodeURIComponent(`https://drive.google.com/uc?export=download&confirm=${match[1]}&id=${fileId}`));
                                        if (cr.ok) { blob = await cr.blob(); if (blob.size > 1000) break; }
                                    }
                                }
                            }
                        } catch(e) {}
                    }
                }
                if (!blob || blob.size < 1000) throw new Error('Download failed');
                currentRomName = name;
                currentRomBlob = blob;
                document.getElementById('now-playing-name').textContent = name;
                document.getElementById('now-playing').classList.add('show');
                initEmulator(URL.createObjectURL(blob), name);
            } catch(error) {
                console.error('Load error:', error);
                statusDot.className = 'status-dot';
                statusText.textContent = 'Failed to load ROM';
            }
        }
        
        function initEmulator(romUrl, gameName) {
            const gameDiv = document.getElementById('game');
            // Keep the touch overlay, remove the placeholder
            const placeholder = gameDiv.querySelector('.game-placeholder');
            if (placeholder) placeholder.remove();
            
            window.EJS_player = '#game';
            window.EJS_core = 'n64';
            window.EJS_gameName = gameName;
            window.EJS_color = '#101010';
            window.EJS_startOnLoaded = true;
            window.EJS_pathtodata = 'https://cdn.emulatorjs.org/stable/data/';
            window.EJS_gameUrl = romUrl;
            window.EJS_VirtualGamepadSettings = false;
            window.EJS_defaultOptions = { 'virtual-gamepad': false };
            window.EJS_Buttons = { playPause:false, restart:false, mute:false, settings:false, fullscreen:false, saveState:false, loadState:false, screenRecord:false, gamepad:false, cheat:false, volume:false, quickSave:false, quickLoad:false, screenshot:false, cacheManager:false };
            const old = document.querySelector('script[src*="emulatorjs"]');
            if (old) old.remove();
            window.EJS_emulator = null;
            emu = null;
            const script = document.createElement('script');
            script.src = 'https://cdn.emulatorjs.org/stable/data/loader.js';
            document.body.appendChild(script);
            document.getElementById('status-text').textContent = 'Loading emulator...';
        }
        
        // ============ AUTO-LOAD SAVE STATE ============
        let saveStateLoaded = false;
        
        async function loadSaveState() {
            if (saveStateLoaded || !emu?.gameManager?.loadState) return;
            try {
                document.getElementById('status-text').textContent = 'Loading save state...';
                const response = await fetch(SAVE_STATE_URL);
                if (!response.ok) throw new Error('HTTP ' + response.status);
                const buffer = await response.arrayBuffer();
                await emu.gameManager.loadState(new Uint8Array(buffer));
                saveStateLoaded = true;
                document.getElementById('status-text').textContent = 'Save state loaded!';
                console.log('Save state loaded successfully');
            } catch(err) {
                console.warn('Save state load failed:', err);
                document.getElementById('status-text').textContent = 'Playing without save state';
            }
        }
        
        // ============ CONTROLS ============
        let controlsSetup = false;
        let gameStarted = false;
        
        function setupControls() {
            const newEmu = window.EJS_emulator;
            if (!newEmu?.gameManager) return false;
            emu = newEmu;
            
            const overlay = document.getElementById('touch-overlay');
            if (!gameStarted) {
                overlay.classList.remove('hidden');
                overlay.style.display = 'flex';
            }
            
            // Load save state once emulator is ready
            if (!saveStateLoaded) {
                setTimeout(loadSaveState, 1500);
            }
            
            if (!controlsSetup) {
                const stickCodes = new Set([16,17,18,19,20,21,22,23]);
                
                // Build button mapping for MY controller
                const btnMap = {};
                const btnNames = {
                    'btn-b': 1, 'btn-a': 0, 'btn-start': 3,
                    'btn-up': 4, 'btn-down': 5, 'btn-left': 6, 'btn-right': 7,
                    'btn-l': 10, 'btn-r': 11, 'btn-z': 12,
                    'btn-cup': 23, 'btn-cdown': 22, 'btn-cleft': 21, 'btn-cright': 20
                };
                
                Object.entries(btnNames).forEach(([name, code]) => {
                    btnMap[prefix + name] = code;
                });
                
                Object.entries(btnMap).forEach(([id, code]) => {
                    const btn = document.getElementById(id);
                    if (!btn) return;
                    const val = stickCodes.has(code) ? 32767 : 1;
                    const press = () => {
                        if (emu?.gameManager) {
                            btn.classList.add('pressed');
                            emu.gameManager.simulateInput(myIndex, code, val);
                            sendInput(code, val);
                        }
                    };
                    const release = () => {
                        if (emu?.gameManager) {
                            btn.classList.remove('pressed');
                            emu.gameManager.simulateInput(myIndex, code, 0);
                            sendInput(code, 0);
                        }
                    };
                    btn.addEventListener('touchstart', e => { e.preventDefault(); press(); }, { passive: false });
                    btn.addEventListener('touchend', e => { e.preventDefault(); release(); }, { passive: false });
                    btn.addEventListener('touchcancel', e => { e.preventDefault(); release(); }, { passive: false });
                    btn.addEventListener('mousedown', e => { e.preventDefault(); press(); });
                    btn.addEventListener('mouseup', e => { e.preventDefault(); release(); });
                    btn.addEventListener('mouseleave', release);
                });
                
                // Keyboard controls (always maps to YOUR player index)
                const keyMap = {
                    "ArrowUp": 19, "ArrowDown": 18, "ArrowLeft": 17, "ArrowRight": 16,
                    "w": 19, "W": 19, "s": 18, "S": 18, "a": 17, "A": 17, "d": 16, "D": 16,
                    "z": 1, "Z": 1, "x": 0, "X": 0, "Enter": 3,
                    "q": 10, "Q": 10, "e": 11, "E": 11, "Shift": 12,
                    "i": 23, "I": 23, "k": 22, "K": 22, "j": 21, "J": 21, "l": 20, "L": 20,
                    "8": 4, "2": 5, "4": 6, "6": 7
                };
                const keysDown = new Set();
                document.addEventListener('keydown', e => {
                    if (emu?.gameManager && keyMap[e.key] !== undefined && !keysDown.has(e.key)) {
                        e.preventDefault(); keysDown.add(e.key);
                        const val = stickCodes.has(keyMap[e.key]) ? 32767 : 1;
                        emu.gameManager.simulateInput(myIndex, keyMap[e.key], val);
                        sendInput(keyMap[e.key], val);
                    }
                });
                document.addEventListener('keyup', e => {
                    if (emu?.gameManager && keyMap[e.key] !== undefined) {
                        e.preventDefault(); keysDown.delete(e.key);
                        emu.gameManager.simulateInput(myIndex, keyMap[e.key], 0);
                        sendInput(keyMap[e.key], 0);
                    }
                });
                
                // Analog stick
                const analogSticks = [];
                const baseId = prefix + 'analog-base';
                const stickId = prefix + 'analog-stick';
                
                (function setupAnalogStick() {
                    const base = document.getElementById(baseId);
                    const stick = document.getElementById(stickId);
                    if (!base || !stick) return;
                    const maxDist = 28;
                    let myTouchId = null, centerX = 0, centerY = 0;
                    let aState = { up:false, down:false, left:false, right:false };
                    
                    function getCenter() {
                        const r = base.getBoundingClientRect();
                        centerX = r.left + r.width/2;
                        centerY = r.top + r.height/2;
                    }
                    function updateAnalog(cx, cy) {
                        let dx = cx - centerX, dy = cy - centerY;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist > maxDist) { dx = (dx/dist)*maxDist; dy = (dy/dist)*maxDist; }
                        stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                        const nx = dx/maxDist, ny = dy/maxDist, t = 0.25;
                        const wR = nx>t, wL = nx<-t, wD = ny>t, wU = ny<-t;
                        if (emu?.gameManager) {
                            if (wU!==aState.up) { const v=wU?32767:0; emu.gameManager.simulateInput(myIndex,19,v); sendInput(19,v); aState.up=wU; }
                            if (wD!==aState.down) { const v=wD?32767:0; emu.gameManager.simulateInput(myIndex,18,v); sendInput(18,v); aState.down=wD; }
                            if (wL!==aState.left) { const v=wL?32767:0; emu.gameManager.simulateInput(myIndex,17,v); sendInput(17,v); aState.left=wL; }
                            if (wR!==aState.right) { const v=wR?32767:0; emu.gameManager.simulateInput(myIndex,16,v); sendInput(16,v); aState.right=wR; }
                        }
                    }
                    function resetAnalog() {
                        stick.style.transform = 'translate(-50%, -50%)';
                        stick.classList.remove('active'); myTouchId = null;
                        if (emu?.gameManager) {
                            if(aState.up){emu.gameManager.simulateInput(myIndex,19,0);sendInput(19,0);aState.up=false;}
                            if(aState.down){emu.gameManager.simulateInput(myIndex,18,0);sendInput(18,0);aState.down=false;}
                            if(aState.left){emu.gameManager.simulateInput(myIndex,17,0);sendInput(17,0);aState.left=false;}
                            if(aState.right){emu.gameManager.simulateInput(myIndex,16,0);sendInput(16,0);aState.right=false;}
                        }
                    }
                    
                    analogSticks.push({ myTouchId: () => myTouchId, updateAnalog, resetAnalog });
                    
                    base.addEventListener('touchstart', e => {
                        e.preventDefault(); e.stopPropagation();
                        if (myTouchId !== null) return;
                        const touch = e.changedTouches[0]; myTouchId = touch.identifier;
                        stick.classList.add('active'); getCenter(); updateAnalog(touch.clientX, touch.clientY);
                    }, {passive:false});
                    
                    let mouseDown = false;
                    base.addEventListener('mousedown', e => {
                        e.preventDefault(); e.stopPropagation();
                        mouseDown = true; stick.classList.add('active'); getCenter(); updateAnalog(e.clientX, e.clientY);
                    });
                    document.addEventListener('mousemove', e => { if(mouseDown) updateAnalog(e.clientX, e.clientY); });
                    document.addEventListener('mouseup', () => { if(mouseDown){mouseDown=false;resetAnalog();} });
                    
                    document.addEventListener('touchmove', e => {
                        for (const t of e.changedTouches) {
                            for (const s of analogSticks) {
                                if (s.myTouchId() === t.identifier) { e.preventDefault(); s.updateAnalog(t.clientX, t.clientY); }
                            }
                        }
                    }, {passive:false});
                    document.addEventListener('touchend', e => {
                        for (const t of e.changedTouches) {
                            for (const s of analogSticks) { if (s.myTouchId() === t.identifier) s.resetAnalog(); }
                        }
                    });
                    document.addEventListener('touchcancel', e => {
                        for (const t of e.changedTouches) {
                            for (const s of analogSticks) { if (s.myTouchId() === t.identifier) s.resetAnalog(); }
                        }
                    });
                })();
                
                controlsSetup = true;
            }
            return true;
        }
        
        // Touch to start
        document.getElementById('touch-overlay').addEventListener('click', () => {
            gameStarted = true;
            document.getElementById('touch-overlay').style.display = 'none';
            new (window.AudioContext || window.webkitAudioContext)().resume();
        });
        document.getElementById('touch-overlay').addEventListener('touchstart', (e) => {
            e.preventDefault(); gameStarted = true;
            document.getElementById('touch-overlay').style.display = 'none';
            new (window.AudioContext || window.webkitAudioContext)().resume();
        }, {passive: false});
        
        // Settings modal
        const settingsModal = document.getElementById('settings-modal');
        document.getElementById('options-btn').addEventListener('click', () => settingsModal.classList.add('show'));
        document.getElementById('settings-close').addEventListener('click', () => settingsModal.classList.remove('show'));
        settingsModal.addEventListener('click', e => { if (e.target === settingsModal) settingsModal.classList.remove('show'); });
        
        document.getElementById('mute-btn').addEventListener('click', e => { if (emu?.gameManager?.setVolume) { isMuted = !isMuted; try { emu.gameManager.setVolume(isMuted ? 0 : 1); } catch {} e.target.textContent = isMuted ? 'üîá OFF' : 'üîä ON'; } });
        document.getElementById('screenshot-btn').addEventListener('click', () => { const canvas = document.querySelector('#game canvas'); if (!canvas) return; const link = document.createElement('a'); link.download = 'pokemon-stadium.png'; link.href = canvas.toDataURL(); link.click(); });
        document.getElementById('save-btn').addEventListener('click', async () => { if (!emu?.gameManager?.getState) return; try { const state = await emu.gameManager.getState(); const link = document.createElement('a'); link.download = 'pokemon_stadium.state'; link.href = URL.createObjectURL(new Blob([state])); link.click(); } catch {} });
        document.getElementById('restart-btn').addEventListener('click', () => { if (emu?.gameManager?.restart && confirm('Restart game?')) emu.gameManager.restart(); settingsModal.classList.remove('show'); });
        
        // ============ EMULATOR READY POLL ============
        setInterval(() => {
            const newEmu = window.EJS_emulator;
            if (newEmu?.gameManager && newEmu !== emu) {
                setupControls();
                document.getElementById('status-text').textContent = 'Ready to play!';
                document.getElementById('status-dot').className = 'status-dot success';
                document.querySelectorAll('[class*="virtualGamepad"]').forEach(el => el.remove());
            }
        }, 100);
        
        // ============ AUTO-LOAD ROM ============
        async function autoLoadPokemonStadium() {
            const statusText = document.getElementById('status-text');
            const statusDot = document.getElementById('status-dot');
            statusDot.className = 'status-dot warning';
            statusText.textContent = 'Finding Pok√©mon Stadium...';
            try {
                const roms = await fetchDriveFolder();
                const stadium = roms.find(r => {
                    const n = r.name.toLowerCase();
                    return (n.includes('pokemon') || n.includes('pok√©mon')) && n.includes('stadium');
                });
                if (stadium) {
                    statusText.textContent = 'Loading Pok√©mon Stadium...';
                    await loadRom(stadium.id, stadium.name);
                } else {
                    statusDot.className = 'status-dot';
                    statusText.textContent = 'ROM not found in library';
                    console.warn('Available:', roms.map(r => r.name));
                }
            } catch(error) {
                console.error('Auto-load error:', error);
                statusDot.className = 'status-dot';
                statusText.textContent = 'Auto-load failed';
            }
        }
        
        // ============ BOOT SEQUENCE ============
        setupPeer();
        autoLoadPokemonStadium();
        
        ['touchstart', 'click'].forEach(evt => document.addEventListener(evt, () => new (window.AudioContext || window.webkitAudioContext)().resume(), { once: true }));
        document.addEventListener('gesturestart', e => e.preventDefault());
    </script>
</body>
</html>
